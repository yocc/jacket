https://pkg.go.dev/time



### Overview [¶](https://pkg.go.dev/time#pkg-overview)

- [Monotonic Clocks](https://pkg.go.dev/time#hdr-Monotonic_Clocks)

Package time provides functionality for measuring and displaying time.

The calendrical calculations always assume a Gregorian calendar, with no leap seconds.

#### Monotonic Clocks [¶](https://pkg.go.dev/time#hdr-Monotonic_Clocks)

Operating systems provide both a “wall clock,” which is subject to changes for clock synchronization, and a “monotonic clock,” which is not. The general rule is that the wall clock is for telling time and the monotonic clock is for measuring time. Rather than split the API, in this package the Time returned by time.Now contains both a wall clock reading and a monotonic clock reading; later time-telling operations use the wall clock reading, but later time-measuring operations, specifically comparisons and subtractions, use the monotonic clock reading.

For example, this code always computes a positive elapsed time of approximately 20 milliseconds, even if the wall clock is changed during the operation being timed:

```
start := time.Now()
... operation that takes 20 milliseconds ...
t := time.Now()
elapsed := t.Sub(start)
```

Other idioms, such as time.Since(start), time.Until(deadline), and time.Now().Before(deadline), are similarly robust against wall clock resets.

The rest of this section gives the precise details of how operations use monotonic clocks, but understanding those details is not required to use this package.

The Time returned by time.Now contains a monotonic clock reading. If Time t has a monotonic clock reading, t.Add adds the same duration to both the wall clock and monotonic clock readings to compute the result. Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time computations, they always strip any monotonic clock reading from their results. Because t.In, t.Local, and t.UTC are used for their effect on the interpretation of the wall time, they also strip any monotonic clock reading from their results. The canonical way to strip a monotonic clock reading is to use t = t.Round(0).

If Times t and u both contain monotonic clock readings, the operations t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out using the monotonic clock readings alone, ignoring the wall clock readings. If either t or u contains no monotonic clock reading, these operations fall back to using the wall clock readings.

On some systems the monotonic clock will stop if the computer goes to sleep. On such a system, t.Sub(u) may not accurately reflect the actual time that passed between t and u.

Because the monotonic clock reading has no meaning outside the current process, the serialized forms generated by t.GobEncode, t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic clock reading, and t.Format provides no format for it. Similarly, the constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix, as well as the unmarshalers t.GobDecode, t.UnmarshalBinary. t.UnmarshalJSON, and t.UnmarshalText always create times with no monotonic clock reading.

Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. See the documentation for the Time type for a discussion of equality testing for Time values.

For debugging, the result of t.String does include the monotonic clock reading if present. If t != u because of different monotonic clock readings, that difference will be visible when printing t.String() and u.String().

### Index [¶](https://pkg.go.dev/time#pkg-index)

- [Constants](https://pkg.go.dev/time#pkg-constants)
- [func After(d Duration) <-chan Time](https://pkg.go.dev/time#After)
- [func Sleep(d Duration)](https://pkg.go.dev/time#Sleep)
- [func Tick(d Duration) <-chan Time](https://pkg.go.dev/time#Tick)
- [type Duration](https://pkg.go.dev/time#Duration)
- - [func ParseDuration(s string) (Duration, error)](https://pkg.go.dev/time#ParseDuration)
  - [func Since(t Time) Duration](https://pkg.go.dev/time#Since)
  - [func Until(t Time) Duration](https://pkg.go.dev/time#Until)
- - [func (d Duration) Hours() float64](https://pkg.go.dev/time#Duration.Hours)
  - [func (d Duration) Microseconds() int64](https://pkg.go.dev/time#Duration.Microseconds)
  - [func (d Duration) Milliseconds() int64](https://pkg.go.dev/time#Duration.Milliseconds)
  - [func (d Duration) Minutes() float64](https://pkg.go.dev/time#Duration.Minutes)
  - [func (d Duration) Nanoseconds() int64](https://pkg.go.dev/time#Duration.Nanoseconds)
  - [func (d Duration) Round(m Duration) Duration](https://pkg.go.dev/time#Duration.Round)
  - [func (d Duration) Seconds() float64](https://pkg.go.dev/time#Duration.Seconds)
  - [func (d Duration) String() string](https://pkg.go.dev/time#Duration.String)
  - [func (d Duration) Truncate(m Duration) Duration](https://pkg.go.dev/time#Duration.Truncate)
- [type Location](https://pkg.go.dev/time#Location)
- - [func FixedZone(name string, offset int) *Location](https://pkg.go.dev/time#FixedZone)
  - [func LoadLocation(name string) (*Location, error)](https://pkg.go.dev/time#LoadLocation)
  - [func LoadLocationFromTZData(name string, data [\]byte) (*Location, error)](https://pkg.go.dev/time#LoadLocationFromTZData)
- - [func (l *Location) String() string](https://pkg.go.dev/time#Location.String)
- [type Month](https://pkg.go.dev/time#Month)
- - [func (m Month) String() string](https://pkg.go.dev/time#Month.String)
- [type ParseError](https://pkg.go.dev/time#ParseError)
- - [func (e *ParseError) Error() string](https://pkg.go.dev/time#ParseError.Error)
- [type Ticker](https://pkg.go.dev/time#Ticker)
- - [func NewTicker(d Duration) *Ticker](https://pkg.go.dev/time#NewTicker)
- - [func (t *Ticker) Reset(d Duration)](https://pkg.go.dev/time#Ticker.Reset)
  - [func (t *Ticker) Stop()](https://pkg.go.dev/time#Ticker.Stop)
- [type Time](https://pkg.go.dev/time#Time)
- - [func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time](https://pkg.go.dev/time#Date)
  - [func Now() Time](https://pkg.go.dev/time#Now)
  - [func Parse(layout, value string) (Time, error)](https://pkg.go.dev/time#Parse)
  - [func ParseInLocation(layout, value string, loc *Location) (Time, error)](https://pkg.go.dev/time#ParseInLocation)
  - [func Unix(sec int64, nsec int64) Time](https://pkg.go.dev/time#Unix)
- - [func (t Time) Add(d Duration) Time](https://pkg.go.dev/time#Time.Add)
  - [func (t Time) AddDate(years int, months int, days int) Time](https://pkg.go.dev/time#Time.AddDate)
  - [func (t Time) After(u Time) bool](https://pkg.go.dev/time#Time.After)
  - [func (t Time) AppendFormat(b [\]byte, layout string) []byte](https://pkg.go.dev/time#Time.AppendFormat)
  - [func (t Time) Before(u Time) bool](https://pkg.go.dev/time#Time.Before)
  - [func (t Time) Clock() (hour, min, sec int)](https://pkg.go.dev/time#Time.Clock)
  - [func (t Time) Date() (year int, month Month, day int)](https://pkg.go.dev/time#Time.Date)
  - [func (t Time) Day() int](https://pkg.go.dev/time#Time.Day)
  - [func (t Time) Equal(u Time) bool](https://pkg.go.dev/time#Time.Equal)
  - [func (t Time) Format(layout string) string](https://pkg.go.dev/time#Time.Format)
  - [func (t *Time) GobDecode(data [\]byte) error](https://pkg.go.dev/time#Time.GobDecode)
  - [func (t Time) GobEncode() ([\]byte, error)](https://pkg.go.dev/time#Time.GobEncode)
  - [func (t Time) Hour() int](https://pkg.go.dev/time#Time.Hour)
  - [func (t Time) ISOWeek() (year, week int)](https://pkg.go.dev/time#Time.ISOWeek)
  - [func (t Time) In(loc *Location) Time](https://pkg.go.dev/time#Time.In)
  - [func (t Time) IsZero() bool](https://pkg.go.dev/time#Time.IsZero)
  - [func (t Time) Local() Time](https://pkg.go.dev/time#Time.Local)
  - [func (t Time) Location() *Location](https://pkg.go.dev/time#Time.Location)
  - [func (t Time) MarshalBinary() ([\]byte, error)](https://pkg.go.dev/time#Time.MarshalBinary)
  - [func (t Time) MarshalJSON() ([\]byte, error)](https://pkg.go.dev/time#Time.MarshalJSON)
  - [func (t Time) MarshalText() ([\]byte, error)](https://pkg.go.dev/time#Time.MarshalText)
  - [func (t Time) Minute() int](https://pkg.go.dev/time#Time.Minute)
  - [func (t Time) Month() Month](https://pkg.go.dev/time#Time.Month)
  - [func (t Time) Nanosecond() int](https://pkg.go.dev/time#Time.Nanosecond)
  - [func (t Time) Round(d Duration) Time](https://pkg.go.dev/time#Time.Round)
  - [func (t Time) Second() int](https://pkg.go.dev/time#Time.Second)
  - [func (t Time) String() string](https://pkg.go.dev/time#Time.String)
  - [func (t Time) Sub(u Time) Duration](https://pkg.go.dev/time#Time.Sub)
  - [func (t Time) Truncate(d Duration) Time](https://pkg.go.dev/time#Time.Truncate)
  - [func (t Time) UTC() Time](https://pkg.go.dev/time#Time.UTC)
  - [func (t Time) Unix() int64](https://pkg.go.dev/time#Time.Unix)
  - [func (t Time) UnixNano() int64](https://pkg.go.dev/time#Time.UnixNano)
  - [func (t *Time) UnmarshalBinary(data [\]byte) error](https://pkg.go.dev/time#Time.UnmarshalBinary)
  - [func (t *Time) UnmarshalJSON(data [\]byte) error](https://pkg.go.dev/time#Time.UnmarshalJSON)
  - [func (t *Time) UnmarshalText(data [\]byte) error](https://pkg.go.dev/time#Time.UnmarshalText)
  - [func (t Time) Weekday() Weekday](https://pkg.go.dev/time#Time.Weekday)
  - [func (t Time) Year() int](https://pkg.go.dev/time#Time.Year)
  - [func (t Time) YearDay() int](https://pkg.go.dev/time#Time.YearDay)
  - [func (t Time) Zone() (name string, offset int)](https://pkg.go.dev/time#Time.Zone)
- [type Timer](https://pkg.go.dev/time#Timer)
- - [func AfterFunc(d Duration, f func()) *Timer](https://pkg.go.dev/time#AfterFunc)
  - [func NewTimer(d Duration) *Timer](https://pkg.go.dev/time#NewTimer)
- - [func (t *Timer) Reset(d Duration) bool](https://pkg.go.dev/time#Timer.Reset)
  - [func (t *Timer) Stop() bool](https://pkg.go.dev/time#Timer.Stop)
- [type Weekday](https://pkg.go.dev/time#Weekday)
- - [func (d Weekday) String() string](https://pkg.go.dev/time#Weekday.String)

#### Examples [¶](https://pkg.go.dev/time#pkg-examples)

- [After](https://pkg.go.dev/time#example-After)
- [Date](https://pkg.go.dev/time#example-Date)
- [Duration](https://pkg.go.dev/time#example-Duration)
- [Duration.Hours](https://pkg.go.dev/time#example-Duration.Hours)
- [Duration.Microseconds](https://pkg.go.dev/time#example-Duration.Microseconds)
- [Duration.Milliseconds](https://pkg.go.dev/time#example-Duration.Milliseconds)
- [Duration.Minutes](https://pkg.go.dev/time#example-Duration.Minutes)
- [Duration.Nanoseconds](https://pkg.go.dev/time#example-Duration.Nanoseconds)
- [Duration.Round](https://pkg.go.dev/time#example-Duration.Round)
- [Duration.Seconds](https://pkg.go.dev/time#example-Duration.Seconds)
- [Duration.String](https://pkg.go.dev/time#example-Duration.String)
- [Duration.Truncate](https://pkg.go.dev/time#example-Duration.Truncate)
- [FixedZone](https://pkg.go.dev/time#example-FixedZone)
- [LoadLocation](https://pkg.go.dev/time#example-LoadLocation)
- [Location](https://pkg.go.dev/time#example-Location)
- [Month](https://pkg.go.dev/time#example-Month)
- [NewTicker](https://pkg.go.dev/time#example-NewTicker)
- [Parse](https://pkg.go.dev/time#example-Parse)
- [ParseDuration](https://pkg.go.dev/time#example-ParseDuration)
- [ParseInLocation](https://pkg.go.dev/time#example-ParseInLocation)
- [Sleep](https://pkg.go.dev/time#example-Sleep)
- [Tick](https://pkg.go.dev/time#example-Tick)
- [Time.Add](https://pkg.go.dev/time#example-Time.Add)
- [Time.AddDate](https://pkg.go.dev/time#example-Time.AddDate)
- [Time.After](https://pkg.go.dev/time#example-Time.After)
- [Time.AppendFormat](https://pkg.go.dev/time#example-Time.AppendFormat)
- [Time.Before](https://pkg.go.dev/time#example-Time.Before)
- [Time.Date](https://pkg.go.dev/time#example-Time.Date)
- [Time.Day](https://pkg.go.dev/time#example-Time.Day)
- [Time.Equal](https://pkg.go.dev/time#example-Time.Equal)
- [Time.Format](https://pkg.go.dev/time#example-Time.Format)
- [Time.Format (Pad)](https://pkg.go.dev/time#example-Time.Format-Pad)
- [Time.Round](https://pkg.go.dev/time#example-Time.Round)
- [Time.String](https://pkg.go.dev/time#example-Time.String)
- [Time.Sub](https://pkg.go.dev/time#example-Time.Sub)
- [Time.Truncate](https://pkg.go.dev/time#example-Time.Truncate)
- [Time.Unix](https://pkg.go.dev/time#example-Time.Unix)

### Constants [¶](https://pkg.go.dev/time#pkg-constants)

[View Source](https://cs.opensource.google/go/go/+/go1.16.7:src/time/format.go;l=73)

```
const (
	ANSIC       = "Mon Jan _2 15:04:05 2006"
	UnixDate    = "Mon Jan _2 15:04:05 MST 2006"
	RubyDate    = "Mon Jan 02 15:04:05 -0700 2006"
	RFC822      = "02 Jan 06 15:04 MST"
	RFC822Z     = "02 Jan 06 15:04 -0700" // RFC822 with numeric zone
	RFC850      = "Monday, 02-Jan-06 15:04:05 MST"
	RFC1123     = "Mon, 02 Jan 2006 15:04:05 MST"
	RFC1123Z    = "Mon, 02 Jan 2006 15:04:05 -0700" // RFC1123 with numeric zone
	RFC3339     = "2006-01-02T15:04:05Z07:00"
	RFC3339Nano = "2006-01-02T15:04:05.999999999Z07:00"
	Kitchen     = "3:04PM"
	// Handy time stamps.
	Stamp      = "Jan _2 15:04:05"
	StampMilli = "Jan _2 15:04:05.000"
	StampMicro = "Jan _2 15:04:05.000000"
	StampNano  = "Jan _2 15:04:05.000000000"
)
```

These are predefined layouts for use in Time.Format and time.Parse. The reference time used in the layouts is the specific time:

```
Mon Jan 2 15:04:05 MST 2006
```

which is Unix time 1136239445. Since MST is GMT-0700, the reference time can be thought of as

```
01/02 03:04:05PM '06 -0700
```

To define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value.

Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information.

Within the format string, an underscore _ represents a space that may be replaced by a digit if the following number (a day) has two digits; for compatibility with fixed-width Unix time formats.

A decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. When parsing (only), the input may contain a fractional second field immediately after the seconds field, even if the layout does not signify its presence. In that case a decimal point followed by a maximal series of digits is parsed as a fractional second.

Numeric time zone offsets format as follows:

```
-0700  ±hhmm
-07:00 ±hh:mm
-07    ±hh
```

Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus:

```
Z0700  Z or ±hhmm
Z07:00 Z or ±hh:mm
Z07    Z or ±hh
```

The recognized day of week formats are "Mon" and "Monday". The recognized month formats are "Jan" and "January".

The formats 2, _2, and 02 are unpadded, space-padded, and zero-padded day of month. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format.

Text in the format string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse.

The executable example for Time.Format demonstrates the working of the layout string in detail and is a good reference.

Note that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use "UTC" as the time zone abbreviation, while strictly speaking those RFCs require the use of "GMT" in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted.

[View Source](https://cs.opensource.google/go/go/+/go1.16.7:src/time/time.go;l=601)

```
const (
	Nanosecond  Duration = 1
	Microsecond          = 1000 * Nanosecond
	Millisecond          = 1000 * Microsecond
	Second               = 1000 * Millisecond
	Minute               = 60 * Second
	Hour                 = 60 * Minute
)
```

Common durations. There is no definition for units of Day or larger to avoid confusion across daylight savings time zone transitions.

To count the number of units in a Duration, divide:

```
second := time.Second
fmt.Print(int64(second/time.Millisecond)) // prints 1000
```

To convert an integer number of units to a Duration, multiply:

```
seconds := 10
fmt.Print(time.Duration(seconds)*time.Second) // prints 10s
```

### Variables [¶](https://pkg.go.dev/time#pkg-variables)

This section is empty.