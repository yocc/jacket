# php mix

[toc]



## Overview





```php
$a ?? 0 等同于 isset($a) ? $a : 0
$a ?: 0 等同于 $a ? $a : 0
empty: 判断一个变量是否为空(null、false、00、0、’0′、』这类，都会返回true)
isset: 判断一个变量是否设置(值为false、00、0、’0′、』这类，也会返回true)
```

```php
?string 它被称为 可空类型，在 PHP 7.1 中引入, 可以传递一个 NULL 值
public function (?string $parameter1, string $parameter2) {}
```

```php
静态与非静态的区别

		静态属性保存在类空间，非静态属性保存在对象空间。非静态方法可以访问类中的任何成员（包括静态），静态方法只能访问类中的静态成员。
  
		静态属性和方法可以直接通过类引用，所以又被称作类属性和类方法。非静态属性和非静态方法需要实例化后通过对象引用，因此被称作对象属性和对象方法。

  	静态方法可以直接调用，类名调用和对象调用（类名或self::调用），但是非静态方法只能通过对象调用（对象名或$this->调用）。

    一个类的所有实例对象，共用类中的静态属性。如果修改了这个类静态属性，那么这个类的所有对象都能访问到这个新值。

    静态方法和属性的生命周期跟相应的类一样长，静态方法和静态属性会随着类的定义而被分配和装载入内存中。一直到线程结束，静态属性和方法才会被销毁。非静态方法和属性的生命周期和类的实例化对象一样长，只有当类实例化了一个对象，非静态方法和属性才会被创建，而当这个对象被销毁时，非静态方法也马上被销毁。

    静态方法和静态变量创建后始终使用同一块内存，而使用实例的方式会创建多个内存。

    但静态方法效率上要比实例化高，静态方法的缺点是不自动进行销毁，而实例化的则可以做销毁。
```

```php
后期静态绑定
后期静态绑定（Late Static Bindings）针对的是静态方法的调用，使用该特性时不再通过 self:: 引用静态方法，而是通过 static::，如果是在定义它的类中调用，则指向当前类，此时和 self 功能一样，如果是在子类或者其他类中调用，则指向调用该方法所在的类

有两点注意:
1. 子类覆盖父类的方法时, 子类方法为 protected, 父类方法为 private;
2. 通过 static::method() 来引用(调用)静态方法. (后期静态绑定)


```





## FAQ







## See Also







